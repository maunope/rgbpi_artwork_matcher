##
## given a set of artwork images for a retrogaming system, it maps filenames to match the format required by rgpbi os
## usage:  sh map.sh %systemname% %outputfolder% sortedgames.dat, note that output folder will be erased a rebuilt from scratch
##

##given a list of image files stored in a file, outputs the intermediate csv file required to map them to rgbpi format
prepareImagesList() {
    local InputFile="$1"
    local OutputFile="$2"

    awk -F'|' 'BEGIN {OFS="|"}{

    ImageFilename = $1;  # Store the original first field
    
    # Replace .png with .zip
    gsub(".png",".zip",$0);

    # Strip round brackets and their contents
    gsub(/\([^)]*\)/,"", $0);   

    # Strip ", The"
    gsub(/, The/, "", $0);

    # Strip ", A"
    gsub(/, A/, "", $0);

    # Strip specified characters
    gsub(/[-_''!]/, "", $0);

    # Remove spaces
    gsub(/ /, "", $0);


    # Extract file name only
    split($0, PathParts, "/");
    SearchKey = PathParts[length(PathParts)];


    # Determine region code
    if (ImageFilename ~ /\((Japan|JAPAN|japan|jap)\)/) {
        Region = "jap";
    } else if (ImageFilename ~ /\((USA|usa|us|US)\)/) {
        Region = "usa";
    } else {
        Region = "eur";
    }
   
    print ImageFilename"|"SearchKey"|"Region 
} ' $InputFile >$OutputFile
}

#
# joins intermediate images list and outputs it to a file containing the game identifier, the region and the original file name. all lines
# in the same file are for the same media type, it is also assumed that all images are for the same platform
createMatches() {
    local InputFile="$1"
    local OutputFile="$2"
    local MatchFile="$3"
    local UnmacthedFile="$4"
    local Platform="$5"

    #temp file with only games for the current platform, platform is the 5th field in the match file
    awk -F '|' '$4 == "'"$Platform"'" {print}' "$MatchFile" > ./temp_filtered_gamesdat.tmp

    join -t '|' -1 2 -2 1 $InputFile ./temp_filtered_gamesdat.tmp | awk -F "|" {'print $2"|"$3"|"$4'}  > $OutputFile

    #create list of unmatched files: do an inner and outer join and the keep the differences
    join -a2  -t '|' -1 2 -2 1 $InputFile ./temp_filtered_gamesdat.tmp | sort  > ./temp_right_join.tmp
    join -a1  -t '|' -1 2 -2 1 $InputFile ./temp_filtered_gamesdat.tmp | sort  > ./temp_left_join.tmp
    
    comm -23 temp_left_join.tmp temp_right_join.tmp | sort | uniq > $UnmacthedFile
}

# given the intermediate format list generated by prepareImagesList(), copies artwork files to the destination folder using
# %code%_[box|ingame|title]_[eur|jap|usa].png format
copyFiles() {
    local InputFile="$1"
    local ArtType="$2"
    local OutputFolder="$3"

    # Cycle through each line in the CSV file
    while IFS='|' read -r field1 field2 field3 rest; do
        # Check if the line has enough fields (at least 3)
        if [ -n "$field3" ]; then
            # Extract the file path from field 1 and check if the file exists
            FilePath="$field1"
            if [ -f "$FilePath" ]; then
                NewFilename="./$OutputFolder/${field3}_"$ArtType"_$field2.png"

                # Copy the file to output folder and rename it
                cp "$FilePath" "$NewFilename"
                echo "Copied and renamed '$FilePath' to '$NewFilename'"
            else
                echo "File not found: $FilePath"
            fi
        else
            echo "Not enough fields in line: $line"
        fi
    done <"$InputFile"
}




# Function to display usage instructions
usage() {
    echo "Usage: $0 Platform OutputFolder MatchFile [--debug] [--resize]"
    echo "param1, param2, param3:  Required positional parameters"
    echo "--debug: if set, doesn't delete temp files and copy images"
    echo "--resize: if set, uses Imagemagick to resize images to fit a 240p screen, skipped in debug mode"
    exit 1  # Exit with an error code if usage is incorrect
}

# Check for the correct number of positional parameters
if [[ $# -lt 3 ]]; then
    usage
fi

# Assign positional parameters to variables
Platform=$1
OutputFolder=$2
MatchFile=$3

# Initialize variables for optional parameters
Debug=false
Resize=false

# Parse optional parameters
while [[ $# -gt 3 ]]; do
    key="$4"
    case $key in
        --debug)
            Debug=true
            shift # Shift to the next argument
            ;;
        --resize)
            Resize=true
            shift # Shift to the next argument
            ;;
        *)
            echo "Error: Unknown option $key"
            usage
            ;;
    esac
done


#todo make these three parametric
ls ./Named_Boxarts/*.png > Named_Boxarts.tmp
ls ./Named_Snaps/*.png > Named_Snaps.tmp
ls ./Named_Titles/*.png > Named_Titles.tmp


#create intermediate input, processed images list
prepareImagesList "Named_Boxarts.tmp" "Prep_Named_Boxarts.tmp" 
prepareImagesList "Named_Snaps.tmp" "Prep_Named_Snaps.tmp" 
prepareImagesList "Named_Titles.tmp" "Prep_Named_Titles.tmp" 

#map with games.dat from rgbpi and output  fields required for renaming only
#todo automate the creation of preprocessed $MatchFile
createMatches Prep_Named_Boxarts.tmp Out_Named_Boxarts.tmp $MatchFile Unmatched_Named_Boxarts.out $Platform
createMatches Prep_Named_Snaps.tmp Out_Named_Snaps.tmp $MatchFile Unmatched_Named_Snaps.out $Platform
createMatches Prep_Named_Titles.tmp Out_Named_Titles.tmp $MatchFile Unmatched_Named_Titles.out $Platform



#output remapped files
if [ "$Debug" != true ]; then

    #clean old results
    rm -rf $OutputFolder
    mkdir $OutputFolder

    copyFiles Out_Named_Boxarts.tmp box $OutputFolder
    copyFiles Out_Named_Snaps.tmp ingame $OutputFolder
    copyFiles Out_Named_Titles.tmp title $OutputFolder

    #clean the workbench
    rm *.tmp

    if [ "$Resize" = true ]; then
        if which mogrify >/dev/null; then
            echo "Resizing images to 300x225, this may take a while."
            mogrify -resize 300x225 ./$OutputFolder/*.png -quality 100
        else
            echo "Please install Imagemagick to enable resizing of images, https://imagemagick.org/index.php"
        fi
    fi
else
    echo "Debug mode, skipped file copy and left temp files on disk"
fi





